{"ast":null,"code":"var _slicedToArray = require(\"/Users/admin/Desktop/Apps/multiplayer-drawing-game/client/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nconst browser = typeof window !== 'undefined';\n\nconst querystring = require('querystring');\n\nconst transport = browser ? require('./browser') : require('./node');\n/**\n * Snekfetch\n * @extends Stream.Readable\n * @extends Promise\n */\n\nclass Snekfetch extends transport.Extension {\n  /**\n   * Options to pass to the Snekfetch constructor\n   * @typedef {object} SnekfetchOptions\n   * @memberof Snekfetch\n   * @property {object} [headers] Headers to initialize the request with\n   * @property {object|string|Buffer} [data] Data to initialize the request with\n   * @property {string|Object} [query] Query to intialize the request with\n   * @property {boolean} [followRedirects=true] If the request should follow redirects\n   * @property {object} [qs=querystring] Querystring module to use, any object providing\n   * `stringify` and `parse` for querystrings\n   * @property {number} [version = 1] The http version to use [1 or 2]\n   * @property {external:Agent} [agent] Whether to use an http agent\n   */\n\n  /**\n   * Create a request.\n   * Usually you'll want to do `Snekfetch#method(url [, options])` instead of\n   * `new Snekfetch(method, url [, options])`\n   * @param {string} method HTTP method\n   * @param {string} url URL\n   * @param {SnekfetchOptions} [opts] Options\n   */\n  constructor(method, url, opts = {}) {\n    super();\n    this.options = Object.assign({\n      version: 1,\n      qs: querystring,\n      followRedirects: true\n    }, opts);\n    this.request = transport.buildRequest.call(this, method, url, opts);\n    if (opts.headers) this.set(opts.headers);\n    if (opts.query) this.query(opts.query);\n    if (opts.data) this.send(opts.data);\n  }\n  /**\n   * Add a query param to the request\n   * @param {string|Object} name Name of query param or object to add to query\n   * @param {string} [value] If name is a string value, this will be the value of the query param\n   * @returns {Snekfetch} This request\n   */\n\n\n  query(name, value) {\n    if (!this.request.query) this.request.query = {};\n\n    if (name !== null && typeof name === 'object') {\n      for (const _ref of Object.entries(name)) {\n        var _ref2 = _slicedToArray(_ref, 2);\n\n        const k = _ref2[0];\n        const v = _ref2[1];\n        this.query(k, v);\n      }\n    } else {\n      this.request.query[name] = value;\n    }\n\n    return this;\n  }\n  /**\n   * Add a header to the request\n   * @param {string|Object} name Name of query param or object to add to headers\n   * @param {string} [value] If name is a string value, this will be the value of the header\n   * @returns {Snekfetch} This request\n   */\n\n\n  set(name, value) {\n    if (name !== null && typeof name === 'object') {\n      for (const key of Object.keys(name)) this.set(key, name[key]);\n    } else {\n      this.request.setHeader(name, value);\n    }\n\n    return this;\n  }\n  /**\n   * Attach a form data object\n   * @param {string} name Name of the form attachment\n   * @param {string|Object|Buffer} data Data for the attachment\n   * @param {string} [filename] Optional filename if form attachment name needs to be overridden\n   * @returns {Snekfetch} This request\n   */\n\n\n  attach(...args) {\n    const form = this.data instanceof transport.FormData ? this.data : this.data = new transport.FormData();\n\n    if (typeof args[0] === 'object') {\n      for (const _ref3 of Object.entries(args[0])) {\n        var _ref4 = _slicedToArray(_ref3, 2);\n\n        const k = _ref4[0];\n        const v = _ref4[1];\n        this.attach(k, v);\n      }\n    } else {\n      form.append(...args);\n    }\n\n    return this;\n  }\n  /**\n   * Send data with the request\n   * @param {string|Buffer|Object} data Data to send\n   * @returns {Snekfetch} This request\n   */\n\n\n  send(data) {\n    if (data instanceof transport.FormData || transport.shouldSendRaw(data)) {\n      this.data = data;\n    } else if (data !== null && typeof data === 'object') {\n      const header = this.request.getHeader('content-type');\n      let serialize;\n\n      if (header) {\n        if (header.includes('json')) serialize = JSON.stringify;else if (header.includes('urlencoded')) serialize = this.options.qs.stringify;\n      } else {\n        this.set('Content-Type', 'application/json');\n        serialize = JSON.stringify;\n      }\n\n      this.data = serialize(data);\n    } else {\n      this.data = data;\n    }\n\n    return this;\n  }\n\n  then(resolver, rejector) {\n    if (this._response) return this._response.then(resolver, rejector); // eslint-disable-next-line no-return-assign\n\n    return this._response = transport.finalizeRequest.call(this).then(({\n      response,\n      raw,\n      redirect,\n      headers\n    }) => {\n      if (redirect) {\n        let method = this.request.method;\n\n        if ([301, 302].includes(response.statusCode)) {\n          if (method !== 'HEAD') method = 'GET';\n          this.data = null;\n        } else if (response.statusCode === 303) {\n          method = 'GET';\n        }\n\n        const redirectHeaders = this.request.getHeaders();\n        delete redirectHeaders.host;\n        return new Snekfetch(method, redirect, {\n          data: this.data,\n          headers: redirectHeaders,\n          version: this.options.version\n        });\n      }\n\n      const statusCode = response.statusCode || response.status; // forgive me :(\n\n      const self = this; // eslint-disable-line consistent-this\n\n      /**\n       * Response from Snekfetch\n       * @typedef {Object} SnekfetchResponse\n       * @memberof Snekfetch\n       * @prop {HTTP.Request} request\n       * @prop {?string|object|Buffer} body Processed response body\n       * @prop {string} text Raw response body\n       * @prop {boolean} ok If the response code is >= 200 and < 300\n       * @prop {number} status HTTP status code\n       * @prop {string} statusText Human readable HTTP status\n       */\n\n      const res = {\n        request: this.request,\n\n        get body() {\n          delete res.body;\n          const type = this.headers['content-type'];\n\n          if (type && type.includes('application/json')) {\n            try {\n              res.body = JSON.parse(res.text);\n            } catch (err) {\n              res.body = res.text;\n            }\n          } else if (type && type.includes('application/x-www-form-urlencoded')) {\n            res.body = self.options.qs.parse(res.text);\n          } else {\n            res.body = raw;\n          }\n\n          return res.body;\n        },\n\n        text: raw.toString(),\n        ok: statusCode >= 200 && statusCode < 400,\n        headers: headers || response.headers,\n        status: statusCode,\n        statusText: response.statusText || transport.STATUS_CODES[response.statusCode]\n      };\n\n      if (res.ok) {\n        return res;\n      } else {\n        const err = new Error(`${res.status} ${res.statusText}`.trim());\n        Object.assign(err, res);\n        return Promise.reject(err);\n      }\n    }).then(resolver, rejector);\n  }\n\n  catch(rejector) {\n    return this.then(null, rejector);\n  }\n  /**\n   * End the request\n   * @param {Function} [cb] Optional callback to handle the response\n   * @returns {Promise} This request\n   */\n\n\n  end(cb) {\n    return this.then(res => cb ? cb(null, res) : res, err => cb ? cb(err, err.status ? err : null) : Promise.reject(err));\n  }\n\n  _finalizeRequest() {\n    if (!this.request) return;\n    if (this.request.method !== 'HEAD') this.set('Accept-Encoding', 'gzip, deflate');\n    if (this.data && this.data.getBoundary) this.set('Content-Type', `multipart/form-data; boundary=${this.data.getBoundary()}`);\n\n    if (this.request.query) {\n      const _this$request$path$sp = this.request.path.split('?'),\n            _this$request$path$sp2 = _slicedToArray(_this$request$path$sp, 2),\n            path = _this$request$path$sp2[0],\n            query = _this$request$path$sp2[1];\n\n      this.request.path = `${path}?${this.options.qs.stringify(this.request.query)}${query ? `&${query}` : ''}`;\n    }\n  }\n\n}\n/**\n * Create a ((THIS)) request\n * @dynamic this.METHODS\n * @method Snekfetch.((THIS)lowerCase)\n * @param {string} url The url to request\n * @param {Snekfetch.snekfetchOptions} [opts] Options\n * @returns {Snekfetch}\n */\n\n\nSnekfetch.METHODS = transport.METHODS.concat('BREW').filter(m => m !== 'M-SEARCH');\n\nfor (const method of Snekfetch.METHODS) {\n  Snekfetch[method.toLowerCase()] = function runMethod(url, opts) {\n    const Constructor = this.prototype instanceof Snekfetch ? this : Snekfetch;\n    return new Constructor(method, url, opts);\n  };\n}\n\nmodule.exports = Snekfetch;\n/**\n * @external Agent\n * @see {@link https://nodejs.org/api/http.html#http_class_http_agent}\n */","map":{"version":3,"sources":["/Users/admin/Desktop/Apps/multiplayer-drawing-game/client/node_modules/snekfetch/src/index.js"],"names":["browser","window","querystring","require","transport","Snekfetch","Extension","constructor","method","url","opts","options","Object","assign","version","qs","followRedirects","request","buildRequest","call","headers","set","query","data","send","name","value","entries","k","v","key","keys","setHeader","attach","args","form","FormData","append","shouldSendRaw","header","getHeader","serialize","includes","JSON","stringify","then","resolver","rejector","_response","finalizeRequest","response","raw","redirect","statusCode","redirectHeaders","getHeaders","host","status","self","res","body","type","parse","text","err","toString","ok","statusText","STATUS_CODES","Error","trim","Promise","reject","catch","end","cb","_finalizeRequest","getBoundary","path","split","METHODS","concat","filter","m","toLowerCase","runMethod","Constructor","prototype","module","exports"],"mappings":"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","sourcesContent":["const browser = typeof window !== 'undefined';\nconst querystring = require('querystring');\nconst transport = browser ? require('./browser') : require('./node');\n\n/**\n * Snekfetch\n * @extends Stream.Readable\n * @extends Promise\n */\nclass Snekfetch extends transport.Extension {\n  /**\n   * Options to pass to the Snekfetch constructor\n   * @typedef {object} SnekfetchOptions\n   * @memberof Snekfetch\n   * @property {object} [headers] Headers to initialize the request with\n   * @property {object|string|Buffer} [data] Data to initialize the request with\n   * @property {string|Object} [query] Query to intialize the request with\n   * @property {boolean} [followRedirects=true] If the request should follow redirects\n   * @property {object} [qs=querystring] Querystring module to use, any object providing\n   * `stringify` and `parse` for querystrings\n   * @property {number} [version = 1] The http version to use [1 or 2]\n   * @property {external:Agent} [agent] Whether to use an http agent\n   */\n\n  /**\n   * Create a request.\n   * Usually you'll want to do `Snekfetch#method(url [, options])` instead of\n   * `new Snekfetch(method, url [, options])`\n   * @param {string} method HTTP method\n   * @param {string} url URL\n   * @param {SnekfetchOptions} [opts] Options\n   */\n  constructor(method, url, opts = {}) {\n    super();\n    this.options = Object.assign({ version: 1, qs: querystring, followRedirects: true }, opts);\n    this.request = transport.buildRequest.call(this, method, url, opts);\n    if (opts.headers)\n      this.set(opts.headers);\n    if (opts.query)\n      this.query(opts.query);\n    if (opts.data)\n      this.send(opts.data);\n  }\n\n  /**\n   * Add a query param to the request\n   * @param {string|Object} name Name of query param or object to add to query\n   * @param {string} [value] If name is a string value, this will be the value of the query param\n   * @returns {Snekfetch} This request\n   */\n  query(name, value) {\n    if (!this.request.query)\n      this.request.query = {};\n    if (name !== null && typeof name === 'object') {\n      for (const [k, v] of Object.entries(name))\n        this.query(k, v);\n    } else {\n      this.request.query[name] = value;\n    }\n\n    return this;\n  }\n\n  /**\n   * Add a header to the request\n   * @param {string|Object} name Name of query param or object to add to headers\n   * @param {string} [value] If name is a string value, this will be the value of the header\n   * @returns {Snekfetch} This request\n   */\n  set(name, value) {\n    if (name !== null && typeof name === 'object') {\n      for (const key of Object.keys(name))\n        this.set(key, name[key]);\n    } else {\n      this.request.setHeader(name, value);\n    }\n\n    return this;\n  }\n\n  /**\n   * Attach a form data object\n   * @param {string} name Name of the form attachment\n   * @param {string|Object|Buffer} data Data for the attachment\n   * @param {string} [filename] Optional filename if form attachment name needs to be overridden\n   * @returns {Snekfetch} This request\n   */\n  attach(...args) {\n    const form = this.data instanceof transport.FormData ? this.data : this.data = new transport.FormData();\n    if (typeof args[0] === 'object') {\n      for (const [k, v] of Object.entries(args[0]))\n        this.attach(k, v);\n    } else {\n      form.append(...args);\n    }\n\n    return this;\n  }\n\n  /**\n   * Send data with the request\n   * @param {string|Buffer|Object} data Data to send\n   * @returns {Snekfetch} This request\n   */\n  send(data) {\n    if (data instanceof transport.FormData || transport.shouldSendRaw(data)) {\n      this.data = data;\n    } else if (data !== null && typeof data === 'object') {\n      const header = this.request.getHeader('content-type');\n      let serialize;\n      if (header) {\n        if (header.includes('json'))\n          serialize = JSON.stringify;\n        else if (header.includes('urlencoded'))\n          serialize = this.options.qs.stringify;\n      } else {\n        this.set('Content-Type', 'application/json');\n        serialize = JSON.stringify;\n      }\n      this.data = serialize(data);\n    } else {\n      this.data = data;\n    }\n    return this;\n  }\n\n  then(resolver, rejector) {\n    if (this._response)\n      return this._response.then(resolver, rejector);\n    // eslint-disable-next-line no-return-assign\n    return this._response = transport.finalizeRequest.call(this)\n      .then(({ response, raw, redirect, headers }) => {\n        if (redirect) {\n          let method = this.request.method;\n          if ([301, 302].includes(response.statusCode)) {\n            if (method !== 'HEAD')\n              method = 'GET';\n            this.data = null;\n          } else if (response.statusCode === 303) {\n            method = 'GET';\n          }\n\n          const redirectHeaders = this.request.getHeaders();\n          delete redirectHeaders.host;\n          return new Snekfetch(method, redirect, {\n            data: this.data,\n            headers: redirectHeaders,\n            version: this.options.version,\n          });\n        }\n\n        const statusCode = response.statusCode || response.status;\n        // forgive me :(\n        const self = this; // eslint-disable-line consistent-this\n        /**\n         * Response from Snekfetch\n         * @typedef {Object} SnekfetchResponse\n         * @memberof Snekfetch\n         * @prop {HTTP.Request} request\n         * @prop {?string|object|Buffer} body Processed response body\n         * @prop {string} text Raw response body\n         * @prop {boolean} ok If the response code is >= 200 and < 300\n         * @prop {number} status HTTP status code\n         * @prop {string} statusText Human readable HTTP status\n         */\n        const res = {\n          request: this.request,\n          get body() {\n            delete res.body;\n            const type = this.headers['content-type'];\n            if (type && type.includes('application/json')) {\n              try {\n                res.body = JSON.parse(res.text);\n              } catch (err) {\n                res.body = res.text;\n              }\n            } else if (type && type.includes('application/x-www-form-urlencoded')) {\n              res.body = self.options.qs.parse(res.text);\n            } else {\n              res.body = raw;\n            }\n\n            return res.body;\n          },\n          text: raw.toString(),\n          ok: statusCode >= 200 && statusCode < 400,\n          headers: headers || response.headers,\n          status: statusCode,\n          statusText: response.statusText || transport.STATUS_CODES[response.statusCode],\n        };\n\n        if (res.ok) {\n          return res;\n        } else {\n          const err = new Error(`${res.status} ${res.statusText}`.trim());\n          Object.assign(err, res);\n          return Promise.reject(err);\n        }\n      })\n      .then(resolver, rejector);\n  }\n\n  catch(rejector) {\n    return this.then(null, rejector);\n  }\n\n  /**\n   * End the request\n   * @param {Function} [cb] Optional callback to handle the response\n   * @returns {Promise} This request\n   */\n  end(cb) {\n    return this.then(\n      (res) => cb ? cb(null, res) : res,\n      (err) => cb ? cb(err, err.status ? err : null) : Promise.reject(err)\n    );\n  }\n\n  _finalizeRequest() {\n    if (!this.request)\n      return;\n\n    if (this.request.method !== 'HEAD')\n      this.set('Accept-Encoding', 'gzip, deflate');\n    if (this.data && this.data.getBoundary)\n      this.set('Content-Type', `multipart/form-data; boundary=${this.data.getBoundary()}`);\n\n    if (this.request.query) {\n      const [path, query] = this.request.path.split('?');\n      this.request.path = `${path}?${this.options.qs.stringify(this.request.query)}${query ? `&${query}` : ''}`;\n    }\n  }\n}\n\n/**\n * Create a ((THIS)) request\n * @dynamic this.METHODS\n * @method Snekfetch.((THIS)lowerCase)\n * @param {string} url The url to request\n * @param {Snekfetch.snekfetchOptions} [opts] Options\n * @returns {Snekfetch}\n */\nSnekfetch.METHODS = transport.METHODS.concat('BREW').filter((m) => m !== 'M-SEARCH');\nfor (const method of Snekfetch.METHODS) {\n  Snekfetch[method.toLowerCase()] = function runMethod(url, opts) {\n    const Constructor = this.prototype instanceof Snekfetch ? this : Snekfetch;\n    return new Constructor(method, url, opts);\n  };\n}\n\nmodule.exports = Snekfetch;\n\n/**\n * @external Agent\n * @see {@link https://nodejs.org/api/http.html#http_class_http_agent}\n */\n"]},"metadata":{},"sourceType":"script"}