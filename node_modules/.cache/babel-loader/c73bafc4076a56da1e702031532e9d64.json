{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports.default = function (e, target, node, place, desiredPlace, effect, offset) {\n  var _getDimensions = getDimensions(node),\n      tipWidth = _getDimensions.width,\n      tipHeight = _getDimensions.height;\n\n  var _getDimensions2 = getDimensions(target),\n      targetWidth = _getDimensions2.width,\n      targetHeight = _getDimensions2.height;\n\n  var _getCurrentOffset = getCurrentOffset(e, target, effect),\n      mouseX = _getCurrentOffset.mouseX,\n      mouseY = _getCurrentOffset.mouseY;\n\n  var defaultOffset = getDefaultPosition(effect, targetWidth, targetHeight, tipWidth, tipHeight);\n\n  var _calculateOffset = calculateOffset(offset),\n      extraOffset_X = _calculateOffset.extraOffset_X,\n      extraOffset_Y = _calculateOffset.extraOffset_Y;\n\n  var windowWidth = window.innerWidth;\n  var windowHeight = window.innerHeight;\n\n  var _getParent = getParent(node),\n      parentTop = _getParent.parentTop,\n      parentLeft = _getParent.parentLeft; // Get the edge offset of the tooltip\n\n\n  var getTipOffsetLeft = function getTipOffsetLeft(place) {\n    var offset_X = defaultOffset[place].l;\n    return mouseX + offset_X + extraOffset_X;\n  };\n\n  var getTipOffsetRight = function getTipOffsetRight(place) {\n    var offset_X = defaultOffset[place].r;\n    return mouseX + offset_X + extraOffset_X;\n  };\n\n  var getTipOffsetTop = function getTipOffsetTop(place) {\n    var offset_Y = defaultOffset[place].t;\n    return mouseY + offset_Y + extraOffset_Y;\n  };\n\n  var getTipOffsetBottom = function getTipOffsetBottom(place) {\n    var offset_Y = defaultOffset[place].b;\n    return mouseY + offset_Y + extraOffset_Y;\n  }; //\n  // Functions to test whether the tooltip's sides are inside\n  // the client window for a given orientation p\n  //\n  //  _____________\n  // |             | <-- Right side\n  // | p = 'left'  |\\\n  // |             |/  |\\\n  // |_____________|   |_\\  <-- Mouse\n  //      / \\           |\n  //       |\n  //       |\n  //  Bottom side\n  //\n\n\n  var outsideLeft = function outsideLeft(p) {\n    return getTipOffsetLeft(p) < 0;\n  };\n\n  var outsideRight = function outsideRight(p) {\n    return getTipOffsetRight(p) > windowWidth;\n  };\n\n  var outsideTop = function outsideTop(p) {\n    return getTipOffsetTop(p) < 0;\n  };\n\n  var outsideBottom = function outsideBottom(p) {\n    return getTipOffsetBottom(p) > windowHeight;\n  }; // Check whether the tooltip with orientation p is completely inside the client window\n\n\n  var outside = function outside(p) {\n    return outsideLeft(p) || outsideRight(p) || outsideTop(p) || outsideBottom(p);\n  };\n\n  var inside = function inside(p) {\n    return !outside(p);\n  };\n\n  var placesList = ['top', 'bottom', 'left', 'right'];\n  var insideList = [];\n\n  for (var i = 0; i < 4; i++) {\n    var p = placesList[i];\n\n    if (inside(p)) {\n      insideList.push(p);\n    }\n  }\n\n  var isNewState = false;\n  var newPlace = void 0;\n  var shouldUpdatePlace = desiredPlace !== place;\n\n  if (inside(desiredPlace) && shouldUpdatePlace) {\n    isNewState = true;\n    newPlace = desiredPlace;\n  } else if (insideList.length > 0 && shouldUpdatePlace && outside(desiredPlace) && outside(place)) {\n    isNewState = true;\n    newPlace = insideList[0];\n  }\n\n  if (isNewState) {\n    return {\n      isNewState: true,\n      newState: {\n        place: newPlace\n      }\n    };\n  }\n\n  return {\n    isNewState: false,\n    position: {\n      left: parseInt(getTipOffsetLeft(place) - parentLeft, 10),\n      top: parseInt(getTipOffsetTop(place) - parentTop, 10)\n    }\n  };\n};\n\nvar getDimensions = function getDimensions(node) {\n  var _node$getBoundingClie = node.getBoundingClientRect(),\n      height = _node$getBoundingClie.height,\n      width = _node$getBoundingClie.width;\n\n  return {\n    height: parseInt(height, 10),\n    width: parseInt(width, 10)\n  };\n}; // Get current mouse offset\n\n/**\n * Calculate the position of tooltip\n *\n * @params\n * - `e` {Event} the event of current mouse\n * - `target` {Element} the currentTarget of the event\n * - `node` {DOM} the react-tooltip object\n * - `place` {String} top / right / bottom / left\n * - `effect` {String} float / solid\n * - `offset` {Object} the offset to default position\n *\n * @return {Object}\n * - `isNewState` {Bool} required\n * - `newState` {Object}\n * - `position` {Object} {left: {Number}, top: {Number}}\n */\n\n\nvar getCurrentOffset = function getCurrentOffset(e, currentTarget, effect) {\n  var boundingClientRect = currentTarget.getBoundingClientRect();\n  var targetTop = boundingClientRect.top;\n  var targetLeft = boundingClientRect.left;\n\n  var _getDimensions3 = getDimensions(currentTarget),\n      targetWidth = _getDimensions3.width,\n      targetHeight = _getDimensions3.height;\n\n  if (effect === 'float') {\n    return {\n      mouseX: e.clientX,\n      mouseY: e.clientY\n    };\n  }\n\n  return {\n    mouseX: targetLeft + targetWidth / 2,\n    mouseY: targetTop + targetHeight / 2\n  };\n}; // List all possibility of tooltip final offset\n// This is useful in judging if it is necessary for tooltip to switch position when out of window\n\n\nvar getDefaultPosition = function getDefaultPosition(effect, targetWidth, targetHeight, tipWidth, tipHeight) {\n  var top = void 0;\n  var right = void 0;\n  var bottom = void 0;\n  var left = void 0;\n  var disToMouse = 3;\n  var triangleHeight = 2;\n  var cursorHeight = 12; // Optimize for float bottom only, cause the cursor will hide the tooltip\n\n  if (effect === 'float') {\n    top = {\n      l: -(tipWidth / 2),\n      r: tipWidth / 2,\n      t: -(tipHeight + disToMouse + triangleHeight),\n      b: -disToMouse\n    };\n    bottom = {\n      l: -(tipWidth / 2),\n      r: tipWidth / 2,\n      t: disToMouse + cursorHeight,\n      b: tipHeight + disToMouse + triangleHeight + cursorHeight\n    };\n    left = {\n      l: -(tipWidth + disToMouse + triangleHeight),\n      r: -disToMouse,\n      t: -(tipHeight / 2),\n      b: tipHeight / 2\n    };\n    right = {\n      l: disToMouse,\n      r: tipWidth + disToMouse + triangleHeight,\n      t: -(tipHeight / 2),\n      b: tipHeight / 2\n    };\n  } else if (effect === 'solid') {\n    top = {\n      l: -(tipWidth / 2),\n      r: tipWidth / 2,\n      t: -(targetHeight / 2 + tipHeight + triangleHeight),\n      b: -(targetHeight / 2)\n    };\n    bottom = {\n      l: -(tipWidth / 2),\n      r: tipWidth / 2,\n      t: targetHeight / 2,\n      b: targetHeight / 2 + tipHeight + triangleHeight\n    };\n    left = {\n      l: -(tipWidth + targetWidth / 2 + triangleHeight),\n      r: -(targetWidth / 2),\n      t: -(tipHeight / 2),\n      b: tipHeight / 2\n    };\n    right = {\n      l: targetWidth / 2,\n      r: tipWidth + targetWidth / 2 + triangleHeight,\n      t: -(tipHeight / 2),\n      b: tipHeight / 2\n    };\n  }\n\n  return {\n    top: top,\n    bottom: bottom,\n    left: left,\n    right: right\n  };\n}; // Consider additional offset into position calculation\n\n\nvar calculateOffset = function calculateOffset(offset) {\n  var extraOffset_X = 0;\n  var extraOffset_Y = 0;\n\n  if (Object.prototype.toString.apply(offset) === '[object String]') {\n    offset = JSON.parse(offset.toString().replace(/\\'/g, '\\\"'));\n  }\n\n  for (var key in offset) {\n    if (key === 'top') {\n      extraOffset_Y -= parseInt(offset[key], 10);\n    } else if (key === 'bottom') {\n      extraOffset_Y += parseInt(offset[key], 10);\n    } else if (key === 'left') {\n      extraOffset_X -= parseInt(offset[key], 10);\n    } else if (key === 'right') {\n      extraOffset_X += parseInt(offset[key], 10);\n    }\n  }\n\n  return {\n    extraOffset_X: extraOffset_X,\n    extraOffset_Y: extraOffset_Y\n  };\n}; // Get the offset of the parent elements\n\n\nvar getParent = function getParent(currentTarget) {\n  var currentParent = currentTarget;\n\n  while (currentParent) {\n    if (window.getComputedStyle(currentParent).getPropertyValue('transform') !== 'none') break;\n    currentParent = currentParent.parentElement;\n  }\n\n  var parentTop = currentParent && currentParent.getBoundingClientRect().top || 0;\n  var parentLeft = currentParent && currentParent.getBoundingClientRect().left || 0;\n  return {\n    parentTop: parentTop,\n    parentLeft: parentLeft\n  };\n};","map":{"version":3,"sources":["/Users/admin/Desktop/Apps/multiplayer-drawing-game/client/node_modules/react-tooltip/dist/utils/getPosition.js"],"names":["Object","defineProperty","exports","value","default","e","target","node","place","desiredPlace","effect","offset","_getDimensions","getDimensions","tipWidth","width","tipHeight","height","_getDimensions2","targetWidth","targetHeight","_getCurrentOffset","getCurrentOffset","mouseX","mouseY","defaultOffset","getDefaultPosition","_calculateOffset","calculateOffset","extraOffset_X","extraOffset_Y","windowWidth","window","innerWidth","windowHeight","innerHeight","_getParent","getParent","parentTop","parentLeft","getTipOffsetLeft","offset_X","l","getTipOffsetRight","r","getTipOffsetTop","offset_Y","t","getTipOffsetBottom","b","outsideLeft","p","outsideRight","outsideTop","outsideBottom","outside","inside","placesList","insideList","i","push","isNewState","newPlace","shouldUpdatePlace","length","newState","position","left","parseInt","top","_node$getBoundingClie","getBoundingClientRect","currentTarget","boundingClientRect","targetTop","targetLeft","_getDimensions3","clientX","clientY","right","bottom","disToMouse","triangleHeight","cursorHeight","prototype","toString","apply","JSON","parse","replace","key","currentParent","getComputedStyle","getPropertyValue","parentElement"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports.default = function (e, target, node, place, desiredPlace, effect, offset) {\n  var _getDimensions = getDimensions(node),\n      tipWidth = _getDimensions.width,\n      tipHeight = _getDimensions.height;\n\n  var _getDimensions2 = getDimensions(target),\n      targetWidth = _getDimensions2.width,\n      targetHeight = _getDimensions2.height;\n\n  var _getCurrentOffset = getCurrentOffset(e, target, effect),\n      mouseX = _getCurrentOffset.mouseX,\n      mouseY = _getCurrentOffset.mouseY;\n\n  var defaultOffset = getDefaultPosition(effect, targetWidth, targetHeight, tipWidth, tipHeight);\n\n  var _calculateOffset = calculateOffset(offset),\n      extraOffset_X = _calculateOffset.extraOffset_X,\n      extraOffset_Y = _calculateOffset.extraOffset_Y;\n\n  var windowWidth = window.innerWidth;\n  var windowHeight = window.innerHeight;\n\n  var _getParent = getParent(node),\n      parentTop = _getParent.parentTop,\n      parentLeft = _getParent.parentLeft;\n\n  // Get the edge offset of the tooltip\n\n\n  var getTipOffsetLeft = function getTipOffsetLeft(place) {\n    var offset_X = defaultOffset[place].l;\n    return mouseX + offset_X + extraOffset_X;\n  };\n  var getTipOffsetRight = function getTipOffsetRight(place) {\n    var offset_X = defaultOffset[place].r;\n    return mouseX + offset_X + extraOffset_X;\n  };\n  var getTipOffsetTop = function getTipOffsetTop(place) {\n    var offset_Y = defaultOffset[place].t;\n    return mouseY + offset_Y + extraOffset_Y;\n  };\n  var getTipOffsetBottom = function getTipOffsetBottom(place) {\n    var offset_Y = defaultOffset[place].b;\n    return mouseY + offset_Y + extraOffset_Y;\n  };\n\n  //\n  // Functions to test whether the tooltip's sides are inside\n  // the client window for a given orientation p\n  //\n  //  _____________\n  // |             | <-- Right side\n  // | p = 'left'  |\\\n  // |             |/  |\\\n  // |_____________|   |_\\  <-- Mouse\n  //      / \\           |\n  //       |\n  //       |\n  //  Bottom side\n  //\n  var outsideLeft = function outsideLeft(p) {\n    return getTipOffsetLeft(p) < 0;\n  };\n  var outsideRight = function outsideRight(p) {\n    return getTipOffsetRight(p) > windowWidth;\n  };\n  var outsideTop = function outsideTop(p) {\n    return getTipOffsetTop(p) < 0;\n  };\n  var outsideBottom = function outsideBottom(p) {\n    return getTipOffsetBottom(p) > windowHeight;\n  };\n\n  // Check whether the tooltip with orientation p is completely inside the client window\n  var outside = function outside(p) {\n    return outsideLeft(p) || outsideRight(p) || outsideTop(p) || outsideBottom(p);\n  };\n  var inside = function inside(p) {\n    return !outside(p);\n  };\n\n  var placesList = ['top', 'bottom', 'left', 'right'];\n  var insideList = [];\n  for (var i = 0; i < 4; i++) {\n    var p = placesList[i];\n    if (inside(p)) {\n      insideList.push(p);\n    }\n  }\n\n  var isNewState = false;\n  var newPlace = void 0;\n  var shouldUpdatePlace = desiredPlace !== place;\n  if (inside(desiredPlace) && shouldUpdatePlace) {\n    isNewState = true;\n    newPlace = desiredPlace;\n  } else if (insideList.length > 0 && shouldUpdatePlace && outside(desiredPlace) && outside(place)) {\n    isNewState = true;\n    newPlace = insideList[0];\n  }\n\n  if (isNewState) {\n    return {\n      isNewState: true,\n      newState: { place: newPlace }\n    };\n  }\n\n  return {\n    isNewState: false,\n    position: {\n      left: parseInt(getTipOffsetLeft(place) - parentLeft, 10),\n      top: parseInt(getTipOffsetTop(place) - parentTop, 10)\n    }\n  };\n};\n\nvar getDimensions = function getDimensions(node) {\n  var _node$getBoundingClie = node.getBoundingClientRect(),\n      height = _node$getBoundingClie.height,\n      width = _node$getBoundingClie.width;\n\n  return {\n    height: parseInt(height, 10),\n    width: parseInt(width, 10)\n  };\n};\n\n// Get current mouse offset\n/**\n * Calculate the position of tooltip\n *\n * @params\n * - `e` {Event} the event of current mouse\n * - `target` {Element} the currentTarget of the event\n * - `node` {DOM} the react-tooltip object\n * - `place` {String} top / right / bottom / left\n * - `effect` {String} float / solid\n * - `offset` {Object} the offset to default position\n *\n * @return {Object}\n * - `isNewState` {Bool} required\n * - `newState` {Object}\n * - `position` {Object} {left: {Number}, top: {Number}}\n */\nvar getCurrentOffset = function getCurrentOffset(e, currentTarget, effect) {\n  var boundingClientRect = currentTarget.getBoundingClientRect();\n  var targetTop = boundingClientRect.top;\n  var targetLeft = boundingClientRect.left;\n\n  var _getDimensions3 = getDimensions(currentTarget),\n      targetWidth = _getDimensions3.width,\n      targetHeight = _getDimensions3.height;\n\n  if (effect === 'float') {\n    return {\n      mouseX: e.clientX,\n      mouseY: e.clientY\n    };\n  }\n  return {\n    mouseX: targetLeft + targetWidth / 2,\n    mouseY: targetTop + targetHeight / 2\n  };\n};\n\n// List all possibility of tooltip final offset\n// This is useful in judging if it is necessary for tooltip to switch position when out of window\nvar getDefaultPosition = function getDefaultPosition(effect, targetWidth, targetHeight, tipWidth, tipHeight) {\n  var top = void 0;\n  var right = void 0;\n  var bottom = void 0;\n  var left = void 0;\n  var disToMouse = 3;\n  var triangleHeight = 2;\n  var cursorHeight = 12; // Optimize for float bottom only, cause the cursor will hide the tooltip\n\n  if (effect === 'float') {\n    top = {\n      l: -(tipWidth / 2),\n      r: tipWidth / 2,\n      t: -(tipHeight + disToMouse + triangleHeight),\n      b: -disToMouse\n    };\n    bottom = {\n      l: -(tipWidth / 2),\n      r: tipWidth / 2,\n      t: disToMouse + cursorHeight,\n      b: tipHeight + disToMouse + triangleHeight + cursorHeight\n    };\n    left = {\n      l: -(tipWidth + disToMouse + triangleHeight),\n      r: -disToMouse,\n      t: -(tipHeight / 2),\n      b: tipHeight / 2\n    };\n    right = {\n      l: disToMouse,\n      r: tipWidth + disToMouse + triangleHeight,\n      t: -(tipHeight / 2),\n      b: tipHeight / 2\n    };\n  } else if (effect === 'solid') {\n    top = {\n      l: -(tipWidth / 2),\n      r: tipWidth / 2,\n      t: -(targetHeight / 2 + tipHeight + triangleHeight),\n      b: -(targetHeight / 2)\n    };\n    bottom = {\n      l: -(tipWidth / 2),\n      r: tipWidth / 2,\n      t: targetHeight / 2,\n      b: targetHeight / 2 + tipHeight + triangleHeight\n    };\n    left = {\n      l: -(tipWidth + targetWidth / 2 + triangleHeight),\n      r: -(targetWidth / 2),\n      t: -(tipHeight / 2),\n      b: tipHeight / 2\n    };\n    right = {\n      l: targetWidth / 2,\n      r: tipWidth + targetWidth / 2 + triangleHeight,\n      t: -(tipHeight / 2),\n      b: tipHeight / 2\n    };\n  }\n\n  return { top: top, bottom: bottom, left: left, right: right };\n};\n\n// Consider additional offset into position calculation\nvar calculateOffset = function calculateOffset(offset) {\n  var extraOffset_X = 0;\n  var extraOffset_Y = 0;\n\n  if (Object.prototype.toString.apply(offset) === '[object String]') {\n    offset = JSON.parse(offset.toString().replace(/\\'/g, '\\\"'));\n  }\n  for (var key in offset) {\n    if (key === 'top') {\n      extraOffset_Y -= parseInt(offset[key], 10);\n    } else if (key === 'bottom') {\n      extraOffset_Y += parseInt(offset[key], 10);\n    } else if (key === 'left') {\n      extraOffset_X -= parseInt(offset[key], 10);\n    } else if (key === 'right') {\n      extraOffset_X += parseInt(offset[key], 10);\n    }\n  }\n\n  return { extraOffset_X: extraOffset_X, extraOffset_Y: extraOffset_Y };\n};\n\n// Get the offset of the parent elements\nvar getParent = function getParent(currentTarget) {\n  var currentParent = currentTarget;\n  while (currentParent) {\n    if (window.getComputedStyle(currentParent).getPropertyValue('transform') !== 'none') break;\n    currentParent = currentParent.parentElement;\n  }\n\n  var parentTop = currentParent && currentParent.getBoundingClientRect().top || 0;\n  var parentLeft = currentParent && currentParent.getBoundingClientRect().left || 0;\n\n  return { parentTop: parentTop, parentLeft: parentLeft };\n};"]},"metadata":{},"sourceType":"script"}