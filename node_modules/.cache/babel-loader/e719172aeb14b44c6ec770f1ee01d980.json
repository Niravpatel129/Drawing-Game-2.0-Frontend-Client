{"ast":null,"code":"const Constants = require('../util/Constants');\n\nclass EmoteParser {\n  /**\r\n   * A parser to replace text with emotes.\r\n   * @param {EmoteFetcher} fetcher - The fetcher to use the cache of.\r\n   * @param {Object} [options={}] - Options for the parser.\r\n   * @param {string} [options.template] - The template to be used.\r\n   * The strings that can be interpolated are:\r\n   * - `{link}` The link of the emote.\r\n   * - `{name}` The name of the emote.\r\n   * - `{size}` The size of the image.\r\n   * - `{creator}` The channel/owner name of the emote.\r\n   * @param {string} [options.type='markdown'] - The type of the parser.\r\n   * Can be one of `markdown`, `html`, `bbcode`, or `plain`.\r\n   * If the `template` option is provided, this is ignored.\r\n   * @param {RegExp} [options.match=/:(.+?):/g] - The regular expression that matches an emote.\r\n   * Must be a global regex, with one capture group for the emote code.\r\n   */\n  constructor(fetcher, options = {}) {\n    /**\r\n     * The emote fetcher being used.\r\n     * @type {EmoteFetcher}\r\n     */\n    this.fetcher = fetcher;\n    /**\r\n     * The parser options.\r\n     * @type {Object}\r\n     */\n\n    this.options = Object.assign({\n      template: '',\n      type: 'markdown',\n      match: /:(.+?):/g\n    }, options);\n\n    this._validateOptions(this.options);\n  }\n\n  _validateOptions(options) {\n    if (options.template && typeof options.template !== 'string') {\n      throw new TypeError('Template must be a string');\n    }\n\n    if (!['markdown', 'html', 'bbcode', 'plain'].includes(options.type)) {\n      throw new TypeError('Parse type must be one of `markdown`, `html`, `bbcode`, or `plain`');\n    }\n\n    if (!(options.match instanceof RegExp) || !options.match.global) {\n      throw new TypeError('Match must be a global RegExp.');\n    }\n  }\n  /**\r\n   * Parses text.\r\n   * @param {string} text - Text to parse.\r\n   * @param {number} size - Size for emotes.\r\n   * @returns {string}\r\n   */\n\n\n  parse(text, size = 0) {\n    const parsed = text.replace(this.options.match, (matched, id) => {\n      const emote = this.fetcher.emotes.get(id);\n      if (!emote) return matched;\n      const template = this.options.template || Constants.Templates[this.options.type];\n      const link = emote.toLink(size);\n      const res = template.replace(/{link}/g, link).replace(/{name}/g, emote.code).replace(/{size}/g, size).replace(/{creator}/g, emote.ownerName || 'global');\n      return res;\n    });\n    return parsed;\n  }\n\n}\n\nmodule.exports = EmoteParser;","map":{"version":3,"sources":["/Users/admin/Desktop/Apps/multiplayer-drawing-game/client/node_modules/twitch-emoticons/src/struct/EmoteParser.js"],"names":["Constants","require","EmoteParser","constructor","fetcher","options","Object","assign","template","type","match","_validateOptions","TypeError","includes","RegExp","global","parse","text","size","parsed","replace","matched","id","emote","emotes","get","Templates","link","toLink","res","code","ownerName","module","exports"],"mappings":"AAAA,MAAMA,SAAS,GAAGC,OAAO,CAAC,mBAAD,CAAzB;;AAEA,MAAMC,WAAN,CAAkB;AACd;;;;;;;;;;;;;;;;AAgBAC,EAAAA,WAAW,CAACC,OAAD,EAAUC,OAAO,GAAG,EAApB,EAAwB;AAC/B;;;;AAIA,SAAKD,OAAL,GAAeA,OAAf;AAEA;;;;;AAIA,SAAKC,OAAL,GAAeC,MAAM,CAACC,MAAP,CAAc;AACzBC,MAAAA,QAAQ,EAAE,EADe;AAEzBC,MAAAA,IAAI,EAAE,UAFmB;AAGzBC,MAAAA,KAAK,EAAE;AAHkB,KAAd,EAIZL,OAJY,CAAf;;AAMA,SAAKM,gBAAL,CAAsB,KAAKN,OAA3B;AACH;;AAEDM,EAAAA,gBAAgB,CAACN,OAAD,EAAU;AACtB,QAAIA,OAAO,CAACG,QAAR,IAAoB,OAAOH,OAAO,CAACG,QAAf,KAA4B,QAApD,EAA8D;AAC1D,YAAM,IAAII,SAAJ,CAAc,2BAAd,CAAN;AACH;;AAED,QAAI,CAAC,CAAC,UAAD,EAAa,MAAb,EAAqB,QAArB,EAA+B,OAA/B,EAAwCC,QAAxC,CAAiDR,OAAO,CAACI,IAAzD,CAAL,EAAqE;AACjE,YAAM,IAAIG,SAAJ,CAAc,oEAAd,CAAN;AACH;;AAED,QAAI,EAAEP,OAAO,CAACK,KAAR,YAAyBI,MAA3B,KAAsC,CAACT,OAAO,CAACK,KAAR,CAAcK,MAAzD,EAAiE;AAC7D,YAAM,IAAIH,SAAJ,CAAc,gCAAd,CAAN;AACH;AACJ;AAED;;;;;;;;AAMAI,EAAAA,KAAK,CAACC,IAAD,EAAOC,IAAI,GAAG,CAAd,EAAiB;AAClB,UAAMC,MAAM,GAAGF,IAAI,CAACG,OAAL,CAAa,KAAKf,OAAL,CAAaK,KAA1B,EAAiC,CAACW,OAAD,EAAUC,EAAV,KAAiB;AAC7D,YAAMC,KAAK,GAAG,KAAKnB,OAAL,CAAaoB,MAAb,CAAoBC,GAApB,CAAwBH,EAAxB,CAAd;AACA,UAAI,CAACC,KAAL,EAAY,OAAOF,OAAP;AAEZ,YAAMb,QAAQ,GAAG,KAAKH,OAAL,CAAaG,QAAb,IAAyBR,SAAS,CAAC0B,SAAV,CAAoB,KAAKrB,OAAL,CAAaI,IAAjC,CAA1C;AACA,YAAMkB,IAAI,GAAGJ,KAAK,CAACK,MAAN,CAAaV,IAAb,CAAb;AACA,YAAMW,GAAG,GAAGrB,QAAQ,CACfY,OADO,CACC,SADD,EACYO,IADZ,EAEPP,OAFO,CAEC,SAFD,EAEYG,KAAK,CAACO,IAFlB,EAGPV,OAHO,CAGC,SAHD,EAGYF,IAHZ,EAIPE,OAJO,CAIC,YAJD,EAIeG,KAAK,CAACQ,SAAN,IAAmB,QAJlC,CAAZ;AAMA,aAAOF,GAAP;AACH,KAbc,CAAf;AAeA,WAAOV,MAAP;AACH;;AA1Ea;;AA6ElBa,MAAM,CAACC,OAAP,GAAiB/B,WAAjB","sourcesContent":["const Constants = require('../util/Constants');\r\n\r\nclass EmoteParser {\r\n    /**\r\n     * A parser to replace text with emotes.\r\n     * @param {EmoteFetcher} fetcher - The fetcher to use the cache of.\r\n     * @param {Object} [options={}] - Options for the parser.\r\n     * @param {string} [options.template] - The template to be used.\r\n     * The strings that can be interpolated are:\r\n     * - `{link}` The link of the emote.\r\n     * - `{name}` The name of the emote.\r\n     * - `{size}` The size of the image.\r\n     * - `{creator}` The channel/owner name of the emote.\r\n     * @param {string} [options.type='markdown'] - The type of the parser.\r\n     * Can be one of `markdown`, `html`, `bbcode`, or `plain`.\r\n     * If the `template` option is provided, this is ignored.\r\n     * @param {RegExp} [options.match=/:(.+?):/g] - The regular expression that matches an emote.\r\n     * Must be a global regex, with one capture group for the emote code.\r\n     */\r\n    constructor(fetcher, options = {}) {\r\n        /**\r\n         * The emote fetcher being used.\r\n         * @type {EmoteFetcher}\r\n         */\r\n        this.fetcher = fetcher;\r\n\r\n        /**\r\n         * The parser options.\r\n         * @type {Object}\r\n         */\r\n        this.options = Object.assign({\r\n            template: '',\r\n            type: 'markdown',\r\n            match: /:(.+?):/g\r\n        }, options);\r\n\r\n        this._validateOptions(this.options);\r\n    }\r\n\r\n    _validateOptions(options) {\r\n        if (options.template && typeof options.template !== 'string') {\r\n            throw new TypeError('Template must be a string');\r\n        }\r\n\r\n        if (!['markdown', 'html', 'bbcode', 'plain'].includes(options.type)) {\r\n            throw new TypeError('Parse type must be one of `markdown`, `html`, `bbcode`, or `plain`');\r\n        }\r\n\r\n        if (!(options.match instanceof RegExp) || !options.match.global) {\r\n            throw new TypeError('Match must be a global RegExp.');\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Parses text.\r\n     * @param {string} text - Text to parse.\r\n     * @param {number} size - Size for emotes.\r\n     * @returns {string}\r\n     */\r\n    parse(text, size = 0) {\r\n        const parsed = text.replace(this.options.match, (matched, id) => {\r\n            const emote = this.fetcher.emotes.get(id);\r\n            if (!emote) return matched;\r\n\r\n            const template = this.options.template || Constants.Templates[this.options.type];\r\n            const link = emote.toLink(size);\r\n            const res = template\r\n                .replace(/{link}/g, link)\r\n                .replace(/{name}/g, emote.code)\r\n                .replace(/{size}/g, size)\r\n                .replace(/{creator}/g, emote.ownerName || 'global');\r\n\r\n            return res;\r\n        });\r\n\r\n        return parsed;\r\n    }\r\n}\r\n\r\nmodule.exports = EmoteParser;\r\n"]},"metadata":{},"sourceType":"script"}