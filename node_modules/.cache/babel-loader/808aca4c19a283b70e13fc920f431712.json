{"ast":null,"code":"const BTTVEmote = require('./BTTVEmote');\n\nconst Channel = require('./Channel');\n\nconst Collection = require('../util/Collection');\n\nconst Constants = require('../util/Constants');\n\nconst FFZEmote = require('./FFZEmote');\n\nconst request = require('snekfetch');\n\nconst TwitchEmote = require('./TwitchEmote');\n\nclass EmoteFetcher {\n  /**\n   * Fetches and caches emotes.\n   */\n  constructor() {\n    /**\n     * Cached emotes.\n     * Collectionped by emote code to Emote instance.\n     * @type {Collection<string, Emote>}\n     */\n    this.emotes = new Collection();\n    /**\n     * Cached channels.\n     * Collectionped by name to Channel instance.\n     * @type {Collection<string, Channel>}\n     */\n\n    this.channels = new Collection();\n  }\n  /**\n   * The global channel for both Twitch and BTTV.\n   * @readonly\n   * @type {?Channel}\n   */\n\n\n  get globalChannel() {\n    return this.channels.get(null);\n  }\n  /**\n   * Gets the raw twitch emotes data.\n   * @private\n   * @returns {Promise<Object>}\n   */\n\n\n  _getRawTwitchEmotes() {\n    return request.get(Constants.Twitch.All).then(res => res.body);\n  }\n  /**\n   * Converts and caches a raw twitch emote.\n   * @private\n   * @param {string} id - ID of the emote.\n   * @param {Object} data - Raw data.\n   * @returns {TwitchEmote}\n   */\n\n\n  _cacheTwitchEmote(id, data) {\n    let channel = this.channels.get(data.channel);\n\n    if (!channel) {\n      channel = new Channel(this, data.channel);\n      this.channels.set(data.channel, channel);\n    }\n\n    channel.title = data.channel_title;\n    const emote = new TwitchEmote(channel, id, data);\n    this.emotes.set(emote.code, emote);\n    channel.emotes.set(emote.code, emote);\n    return emote;\n  }\n  /**\n   * Gets the raw BTTV emotes data for a channel.\n   * @private\n   * @param {string} name - Name of the channel.\n   * @returns {Promise<Object[]>}\n   */\n\n\n  _getRawBTTVEmotes(name) {\n    const endpoint = !name ? Constants.BTTV.Global : Constants.BTTV.Channel(name); // eslint-disable-line new-cap\n\n    return request.get(endpoint).then(res => res.body.emotes);\n  }\n  /**\n   * Converts and caches a raw BTTV emote.\n   * @private\n   * @param {string} name - Name of the channel.\n   * @param {Object} data - Raw data.\n   * @returns {BTTVEmote}\n   */\n\n\n  _cacheBTTVEmote(name, data) {\n    let channel = this.channels.get(name);\n\n    if (!channel) {\n      channel = new Channel(this, name);\n      this.channels.set(name, channel);\n    }\n\n    const emote = new BTTVEmote(channel, data.id, data);\n    this.emotes.set(emote.code, emote);\n    channel.emotes.set(emote.code, emote);\n    return emote;\n  }\n  /**\n   * Gets the raw FFZ emotes data for a channel.\n   * @private\n   * @param {string} name - Name of the channel.\n   * @returns {Promise<Object[]>}\n   */\n\n\n  _getRawFFZEmotes(name) {\n    return request.get(Constants.FFZ.Channel(name)).then(res => {\n      // eslint-disable-line new-cap\n      const emotes = [];\n\n      for (const key of Object.keys(res.body.sets)) {\n        const set = res.body.sets[key];\n        emotes.push(...set.emoticons);\n      }\n\n      return emotes;\n    });\n  }\n  /**\n   * Converts and caches a raw FFZ emote.\n   * @private\n   * @param {string} name - Name of the channel.\n   * @param {Object} data - Raw data.\n   * @returns {FFZEmote}\n   */\n\n\n  _cacheFFZEmote(name, data) {\n    let channel = this.channels.get(name);\n\n    if (!channel) {\n      channel = new Channel(this, name);\n      this.channels.set(name, channel);\n    }\n\n    const emote = new FFZEmote(channel, data.id, data);\n    this.emotes.set(emote.code, emote);\n    channel.emotes.set(emote.code, emote);\n    return emote;\n  }\n  /**\n   * Fetches and caches all twitch emotes.\n   * If channel names are specified, will only cache those channels.\n   * Use `null` for the global emotes channel.\n   * @param {string|string[]} [names] - Names of channels to cache.\n   * @returns {Promise<Collection<string, TwitchEmote>>}\n   */\n\n\n  fetchTwitchEmotes(names) {\n    if (names && !Array.isArray(names)) names = [names];\n    return this._getRawTwitchEmotes().then(rawEmotes => {\n      for (const key of Object.keys(rawEmotes)) {\n        const data = rawEmotes[key];\n\n        if (names === undefined || names.includes(data.channel)) {\n          this._cacheTwitchEmote(key, data);\n        }\n      }\n\n      return this.emotes.filter(e => e.type === 'twitch');\n    });\n  }\n  /**\n   * Fetches the BTTV emotes for a channel.\n   * Use `null` for the global emotes channel.\n   * @param {string} [name=null] - Name of the channel.\n   * @returns {Promise<Collection<string, BTTVEmote>>}\n   */\n\n\n  fetchBTTVEmotes(name = null) {\n    return this._getRawBTTVEmotes(name).then(rawEmotes => {\n      for (const data of rawEmotes) {\n        this._cacheBTTVEmote(name, data);\n      }\n\n      return this.channels.get(name).emotes.filter(e => e.type === 'bttv');\n    });\n  }\n  /**\n   * Fetches the FFZ emotes for a channel.\n   * @param {string} name - Name of the channel.\n   * @returns {Promise<Collection<string, FFZEmote>>}\n   */\n\n\n  fetchFFZEmotes(name) {\n    return this._getRawFFZEmotes(name).then(rawEmotes => {\n      for (const data of rawEmotes) {\n        this._cacheFFZEmote(name, data);\n      }\n\n      return this.channels.get(name).emotes.filter(e => e.type === 'ffz');\n    });\n  }\n\n}\n\nmodule.exports = EmoteFetcher;","map":{"version":3,"sources":["/Users/admin/Desktop/Apps/multiplayer-drawing-game/client/node_modules/twitch-emoticons/src/struct/EmoteFetcher.js"],"names":["BTTVEmote","require","Channel","Collection","Constants","FFZEmote","request","TwitchEmote","EmoteFetcher","constructor","emotes","channels","globalChannel","get","_getRawTwitchEmotes","Twitch","All","then","res","body","_cacheTwitchEmote","id","data","channel","set","title","channel_title","emote","code","_getRawBTTVEmotes","name","endpoint","BTTV","Global","_cacheBTTVEmote","_getRawFFZEmotes","FFZ","key","Object","keys","sets","push","emoticons","_cacheFFZEmote","fetchTwitchEmotes","names","Array","isArray","rawEmotes","undefined","includes","filter","e","type","fetchBTTVEmotes","fetchFFZEmotes","module","exports"],"mappings":"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","sourcesContent":["const BTTVEmote = require('./BTTVEmote');\nconst Channel = require('./Channel');\nconst Collection = require('../util/Collection');\nconst Constants = require('../util/Constants');\nconst FFZEmote = require('./FFZEmote');\nconst request = require('snekfetch');\nconst TwitchEmote = require('./TwitchEmote');\n\nclass EmoteFetcher {\n    /**\n     * Fetches and caches emotes.\n     */\n    constructor() {\n        /**\n         * Cached emotes.\n         * Collectionped by emote code to Emote instance.\n         * @type {Collection<string, Emote>}\n         */\n        this.emotes = new Collection();\n\n        /**\n         * Cached channels.\n         * Collectionped by name to Channel instance.\n         * @type {Collection<string, Channel>}\n         */\n        this.channels = new Collection();\n    }\n\n    /**\n     * The global channel for both Twitch and BTTV.\n     * @readonly\n     * @type {?Channel}\n     */\n    get globalChannel() {\n        return this.channels.get(null);\n    }\n\n    /**\n     * Gets the raw twitch emotes data.\n     * @private\n     * @returns {Promise<Object>}\n     */\n    _getRawTwitchEmotes() {\n        return request.get(Constants.Twitch.All).then(res => res.body);\n    }\n\n    /**\n     * Converts and caches a raw twitch emote.\n     * @private\n     * @param {string} id - ID of the emote.\n     * @param {Object} data - Raw data.\n     * @returns {TwitchEmote}\n     */\n    _cacheTwitchEmote(id, data) {\n        let channel = this.channels.get(data.channel);\n        if (!channel) {\n            channel = new Channel(this, data.channel);\n            this.channels.set(data.channel, channel);\n        }\n\n        channel.title = data.channel_title;\n        const emote = new TwitchEmote(channel, id, data);\n        this.emotes.set(emote.code, emote);\n        channel.emotes.set(emote.code, emote);\n        return emote;\n    }\n\n    /**\n     * Gets the raw BTTV emotes data for a channel.\n     * @private\n     * @param {string} name - Name of the channel.\n     * @returns {Promise<Object[]>}\n     */\n    _getRawBTTVEmotes(name) {\n        const endpoint = !name\n        ? Constants.BTTV.Global\n        : Constants.BTTV.Channel(name); // eslint-disable-line new-cap\n\n        return request.get(endpoint).then(res => res.body.emotes);\n    }\n\n    /**\n     * Converts and caches a raw BTTV emote.\n     * @private\n     * @param {string} name - Name of the channel.\n     * @param {Object} data - Raw data.\n     * @returns {BTTVEmote}\n     */\n    _cacheBTTVEmote(name, data) {\n        let channel = this.channels.get(name);\n        if (!channel) {\n            channel = new Channel(this, name);\n            this.channels.set(name, channel);\n        }\n\n        const emote = new BTTVEmote(channel, data.id, data);\n        this.emotes.set(emote.code, emote);\n        channel.emotes.set(emote.code, emote);\n        return emote;\n    }\n\n    /**\n     * Gets the raw FFZ emotes data for a channel.\n     * @private\n     * @param {string} name - Name of the channel.\n     * @returns {Promise<Object[]>}\n     */\n    _getRawFFZEmotes(name) {\n        return request.get(Constants.FFZ.Channel(name)).then(res => { // eslint-disable-line new-cap\n            const emotes = [];\n            for (const key of Object.keys(res.body.sets)) {\n                const set = res.body.sets[key];\n                emotes.push(...set.emoticons);\n            }\n\n            return emotes;\n        });\n    }\n\n    /**\n     * Converts and caches a raw FFZ emote.\n     * @private\n     * @param {string} name - Name of the channel.\n     * @param {Object} data - Raw data.\n     * @returns {FFZEmote}\n     */\n    _cacheFFZEmote(name, data) {\n        let channel = this.channels.get(name);\n        if (!channel) {\n            channel = new Channel(this, name);\n            this.channels.set(name, channel);\n        }\n\n        const emote = new FFZEmote(channel, data.id, data);\n        this.emotes.set(emote.code, emote);\n        channel.emotes.set(emote.code, emote);\n        return emote;\n    }\n\n    /**\n     * Fetches and caches all twitch emotes.\n     * If channel names are specified, will only cache those channels.\n     * Use `null` for the global emotes channel.\n     * @param {string|string[]} [names] - Names of channels to cache.\n     * @returns {Promise<Collection<string, TwitchEmote>>}\n     */\n    fetchTwitchEmotes(names) {\n        if (names && !Array.isArray(names)) names = [names];\n        return this._getRawTwitchEmotes().then(rawEmotes => {\n            for (const key of Object.keys(rawEmotes)) {\n                const data = rawEmotes[key];\n                if (names === undefined || names.includes(data.channel)) {\n                    this._cacheTwitchEmote(key, data);\n                }\n            }\n\n            return this.emotes.filter(e => e.type === 'twitch');\n        });\n    }\n\n    /**\n     * Fetches the BTTV emotes for a channel.\n     * Use `null` for the global emotes channel.\n     * @param {string} [name=null] - Name of the channel.\n     * @returns {Promise<Collection<string, BTTVEmote>>}\n     */\n    fetchBTTVEmotes(name = null) {\n        return this._getRawBTTVEmotes(name).then(rawEmotes => {\n            for (const data of rawEmotes) {\n                this._cacheBTTVEmote(name, data);\n            }\n\n            return this.channels.get(name).emotes.filter(e => e.type === 'bttv');\n        });\n    }\n\n    /**\n     * Fetches the FFZ emotes for a channel.\n     * @param {string} name - Name of the channel.\n     * @returns {Promise<Collection<string, FFZEmote>>}\n     */\n    fetchFFZEmotes(name) {\n        return this._getRawFFZEmotes(name).then(rawEmotes => {\n            for (const data of rawEmotes) {\n                this._cacheFFZEmote(name, data);\n            }\n\n            return this.channels.get(name).emotes.filter(e => e.type === 'ffz');\n        });\n    }\n}\n\nmodule.exports = EmoteFetcher;\n"]},"metadata":{},"sourceType":"script"}